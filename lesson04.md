# Урок 4. Списки, рядки та генератор списків

## Мінливі та незмінні типи даних

У Python є мінливі (mutable) та незмінні (immutable) типи даних.

Раніше розглядався тип даних int, який є незмінним. Так само незмінними є типи даних tuple (кортеж) і string (рядок).

Що значить незмінні? Значить, що вже створений рядок ми не можемо змінити. Це легко покажуть подальші приклади із рядками і кортежами. Якщо ж здається, що об'єкт одного з перерахованих даних змінився - значить, тепер ім'я об'єкта просто вказує на нову область пам'яті з новим об'єктом.

### Зрізи строк

Python дозволяє взяти частину рядка або навіть скласти з елементів рядка будь-який новий рядок, використовуючи фрагменти (зрізи). Приклади:

```python
>>> S = "Welcome to California!"
>>> S
'Welcome to California!'
>>> S[:5]
'Welco'
>>> S[5:]
'me to California!'
>>> S[:]
'Welcome to California!'
>>> S[:-3]
'Welcome to Californ'
>>> S[::-1]
'!ainrofilaC ot emocleW'
>>> S[:5:2]
'Wlo'
```

З прикладу видно, що зрізи створюються шляхом вказівки у квадратних дужках обов'язкової двокрапки. Число до двокрапки - від якого елемента показувати, після - до якого, не включаючи його. Якщо не вказано перше число - показати від початку, якщо не вказано друге - до кінця. Друга двокрапка дозволяє вказати третє число - крок, з яким потрібно йти по послідовності.


# List (список)

### Створення списків

Списки задаються багатьма способами: 

```python
# empty list
>>>empty_list = []
# Simple listing
>>> a = [2, 2.25, "Python"]
>>> a
[2, 2.25, 'Python']

# Transforming the string to a list
>>> b = list("help")
>>> b
['h', 'e', 'l', 'p']

>>> b = 'welcome to the hell'.split()
>>> b
['welcome', 'to', 'the', 'hell']

```

### Операції зрізів та вставок зі списками

До списків застосовні всі зрізи, що застосовуються до рядків. На додаток, до списків таким чином можна ще й додавати нові елементи.

```python
L = [1, 2, 's']
>>> L
[1, 2, 's']
>>> L[1:3]
[2, 's']
>>> L[2] = '17'
>>> L
[1, 2, '17']
>>> L[1:2]
[2]
>>> L[1:2] = ['new', 'list']
>>> L
[1, 'new', 'list', '17']
```


### Деякі функції, що працюють зі списками

```python
>>> L = list(range(1, 11))
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> L.append(12) # Adds element at the end of the list
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]
>>> L.extend([13, 14]) # Adds second's list elements to the end of the first list
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14]
>>> L.insert(2, 5) # Insert 5 to the second place (index)
>>> L
[1, 2, 5, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14]
>>> L.remove(5) # Removes the first 5 appeared
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14]
```


```python
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# map function applies the method given to the iterable proposed
>>> L = list(map(str, range(1, 11)))
>>> L # Here we have casted all integers to strings
['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
>>> S = ': '.join(L) # concats small strings into one big, using "glue". Starts as a method of "glue"
>>> S
'1: 2: 3: 4: 5: 6: 7: 8: 9: 10'
```

### Цикли та списки

Цикл for спеціально створений для того, щоб виконувати повторювані дії з ітерованими об'єктами, утому числі зі списками. Пара прикладів:

```python
>>> S = 'This is Sparta!!'
>>> L = S.split()
>>> L
['This', 'is', 'Sparta!!']
>>> for elem in L:
...     print('say ' + elem)
...
say This
say is
say Sparta!!

>>> for num, elem in enumerate(L):
...     print (str(num) + '. say ' + elem)
...
0. say This
1. say is
2. say Sparta!!
```

Зверніть увагу на функцію enumerate, яка видає не лише вміст списку, а і його порядковий номер.

### List comprehensions (Спискові включення)

У мовах програмування є таке поняття, як синтаксичний цукор. Це можливості мови за деяким спрощенням мовних конструкцій, які не впливають на виконання конструкцій, але спрощують життя програміста. Найпопулярніший і найпоширеніший приклад - спискові включення, list comprehensions.

Нижче наведено приклади приведення звичайного циклу до спискового включення:

```python
>>> l = []
>>> for x in range(1, 11):
...     l.append(x*x)
...
>>> l
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# now with the list comprehension
>>> l2 = [x*x for x in range(1, 11)]
>>> l2
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

Синтаксис у list comprehensions приблизно такий:

`result_list = [actions_with_var for var in list if condition]`

Як видно з синтаксису, можна навіть додати перевірку певної умови, по виконанні якої ми додаватимемо або не додаватимемо елемент до результівного списку:

```python
e = 's o m e t e x t' 
a = [x*2 for x in e if x!=' ']
print(a)
# ['ss', 'oo', 'mm', 'ee', 'tt', 'ee', 'xx', 'tt']
```

Насправді ця конструкція є прикладом генераторного виразу, що перевіряється обрамленням її не квардатними, а круглими дужками і перевіркою типу даних на виході:

```python
>>> a=(x for x in range(10))
>>> type(a)
<class 'generator'>
```
А у прикладах наведених вище відбувалося перетворення згенерованих даних на льоту у елементи списку, завдяки ініціалізації змінної, як списку.

## Посилання

[List comprehensions за 5 хвилин](https://medium.com/nuances-of-programming/list-comprehensions-%D0%B2-python-%D0%B7%D0%B0-5-%D0%BC%D0%B8%D0%BD%D1%83%D1%82-4e5ff3cafd62)

[Зрізи](https://habr.com/ru/post/319200/)

## Домашнє завдання №4

1. Продовжуємо писати практики з заняття.
2. Закінчуємо попередні завдання, прикрашаємо наші роботи (фізбаз особливо) рядками, списками, list comprehensions...
3. Якщо болі замало, [Хардкор для охочих](https://habr.com/ru/post/320288/)
