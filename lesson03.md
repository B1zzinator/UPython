# Урок 3. Цикли For та While, робота з файлами

## Оператори циклу

Коли в програміста виникає необхідність повторити якусь дію кілька разів, він пише цикл.
У python є оператори циклу `while` та `for`.
У більшості випадків оператори циклу взаємозамінні, але кожен з них має деякі нюанси.


## Цикл while

Найпростіший оператор циклу while виглядає так:

**`while умова: дія`**

або

**`while умова: блок дій в декілька рядків`**

Логічно і синтаксично операторо циклу `while` дуже схожий з оператором розгалудження `if`. У обох випадках выдбувається перевірка умови, і у разі її істинності (тобто умова=`True`) виконуються команди, які у даному випадку називаються "тілом циклу". І так само, як і у випадку з `if`, у циклів у Пайтоні може бути повне розгалуження із застосуванням гілки `else`, яке буде виконуватись у разі хибності умови (тобто умова=`False`). Головна відмінність між `if` та `while` полягає у тому, що при розгалудженні команди виконуються одноразово, а у циклі інтерпертатор повертається до початкової перевірки умови після кожного повтору циклу.

```python
i = res = 0
while i < 11:
    res += i
    i += 1
print(res)
```

## Вічний (нескінченний) цикл

![](http://risovach.ru/upload/2015/02/mem/fon_73228276_orig_.jpg)
У програмуванні часто використовуються вічні цикли. Просто є ситуації, коли немає явного обмеження і умову важко перевірити заздалегідь. Для того, щоб вийти з вічного циклу і взагалі з циклу, використовується оператор `break`. Він працює всередині циклу та припиняє його виконання. Далі проілюстровано роботу оператора `break` та оператора `continue`, який припиняє поточну ітерацію та починає наступну:

```python
i = 10
while True:
    i -= 1
    if not i: continue
    if i%2:
        print(i)
    if i < -10: break
```
У цій можливості оператору `while` криється його небезпека: якщо неграмотно скласти обробку умови та її зміну всередині тіла циклу, то вн легко увійде у режим вічного повтору і програма може просто підвиснути. Також у цикла `while`, завдяки факту перевірки умови ПЕРЕД здійсненням дій з інформацією є можливість, при неграмотному складанні алгоритму вчинити одну лишню ітерацію (повтора тіла циклу) і видати результат відмінний від очікуваного. Цих нелоліків позбавлений наступний оператор циклу, який деякі ортодоксальні програмісти також прирівнюють до "синтаксичного цукру".


## Оператор циклу for

На відміну від `while` оператор циклу `for` має явно вказану кінечність, оскільки здійснює повтори виклюно згідно кількості елементів ітерованого об'єкта, який йому передається.
Те саме підсумовування перших 10 елементів, що й за допомогою циклу `while`, але за допомогою `for`:

```python
sum = 0
for i in range(1, 11):
    sum += i
print(sum)
```
У даному випадку використано генераторний вираз range(a,b,c), який створіє послідовність цілих чисел починаючи з 'a' до, але не включаючи 'b', з кроком 'c'. Слід відмітити, що для даного генератора параметри 'a' та 'c' не є обов'язковими. Також, у випадку неправильного вказання параметрів для такого генератора (наприклад, вказавши кінцеве значення менше початкового при додатньому кроку) цикл `for` можна ввести у нескічненні повтори.

Оскільки цикл `for` виконується в рамках ітерованого об'єкту, то він чуже часто використовується для перебору значень цього самого ітерованого об'єкту (рядка, генератора, списку, кортежу тощо):

```python
sum = []
for i in 'word':
    sum += i
print(sum)
```
Бувають ситуації, коли виникає необхідність не просто поелементного перебору ітерованого об'єкту, але й встановлення індексу кожного його елемента. У цьому випадку використовуєтсья метод `enumerate()`, котрий додає до ітерованого об'єкту лічильник і повертає його у вигляді нумерованого об'єкту. Цей нумерований об'єкт у подальшому може бути використаний напряму у циклах `for` або конвертований у список, кожен елемент якого є кортежем за допомогою функції `list()`.

Синтаксис функції: enumerate(iterable, start=0)
де: iterable - ітерований об'єкт; start - початкове значення індексу (0 за замовчуванням)

```python
a = [10, 20, 30, 40]
for id, item in enumerate(a):
    a[id] = item + 5
print(a)

[15, 25, 35, 45]
```
```python
l1 = ["eat", "sleep", "repeat"]
s1 = "geek"
  
# створюємо нумеровані об'єкти
obj1 = enumerate(l1)
obj2 = enumerate(s1)
  
print ("Return type:", type(obj1)) #Return type: <class 'enumerate'>
print (list(enumerate(l1))) #[(0, 'eat'), (1, 'sleep'), (2, 'repeat')]
  
# замінюємо початковий індекс на 2
print (list(enumerate(s1, 2))) #[(2, 'g'), (3, 'e'), (4, 'e'), (5, 'k')]
```

Слід відмітити, що внутрішня реалізація у пайтоні циклу `for` є швидшою за код циклу `while`. І при одних і тих самих умовах цикл `for` виконається приблизно на 20-50% щвидше. Тим не менше, якщо швидкість виконання для вас є критичною, то варто уникати використання будь-яких циклів і користуватись вбудованими функціями і методами мови Пайтон (наприклад мета-функцією `map()`, чи функцыями типу `max()`,`min()`,`sort()` та ін.), оскільки вони будуть набагато швидші за будь-який цикл реалізований на самій мові.

## Базова робота з файлами

Для роботи з файлами вам потрібні такі функції:

* open
* write
* read
* close

Приклади:

```python
import sys
filename = sys.argv[1]
# далі відкриваємо файл для читання (опція 'r')
f = open(filename, 'r') # в файлі тепер file descriptor
for line in f: # для кожного рядка у файлі
	print(line)
f.close() # закриття файлу

```


Тут треба звернути увагу на такі рядки:
**`import sys`** - включення до нашої програми бібліотеки системних функцій, з допомогою якої ми можемо працювати з параметрами командного рядка, наприклад. 
**`filename = sys.argv[1]`, де sys.argv** - функція системної бібліотеки sys. Вона зчитує перший параметр зі списку параметрів командного рядка.

Якщо здійснимо виклик файлу нашої програми prog.py в консолі, і передамо їй файл ось так:

```bash
C:\python3\python.exe prog.py testfile.txt
```
...то python вважає за нульовий параметр ім'я нашої програми (prog.py), першим = ім'я переданого файлу (testfile.txt), другим - наступний параметр, якщо він є, і так далі.
Таким чином ми передали програмі файл, прочитали його по рядках та вивели. На цей час поки що по роботі з файлами цього достатньо.

Для відкриття файлу у режимі запису до нього використовується та ж функція open(), але вже з ключем 'w'. А безпосередньо для запису у нього використовується метод .write(). Однак запис у файл має декілька підводних каменів. Зокрема, у багатьох підручниках записано такий приклад для запису і закриття файлу: 

```python
f=open('file.txt','w')
f.write('hello')
f.close() 
```
Але При використанні даного алгоритму можуть виникати наступні помилки:

    1. Помилка доступу: може виникнути помилка, якщо користувач не має дозволу на запис до файлу. Наприклад, якщо файл вже відкритий у іншому додатку або якщо користувач не має достатніх дозволів на запис до файлу.

    2. Помилка шляху до файлу: може виникнути помилка, якщо файл не знайдено в заданому шляху. Перевірте, чи існує файл в заданому шляху, а також чи вірно вказаний шлях до файлу.

    3. Помилка запису: може виникнути помилка, якщо не вдалося записати дані до файлу. Наприклад, якщо недостатньо пам'яті на диску або якщо диск заблокований.

    4. Помилка відкриття файлу: може виникнути помилка, якщо файл не відкривається. Наприклад, якщо файл уже відкритий у іншому процесі або якщо він був переміщений або видалений.

    5. Помилка кодування: може виникнути помилка, якщо використовується неправильне кодування файлу. Наприклад, якщо використовується кодування, відмінне від кодування файлу, то можуть виникнути проблеми з відображенням тексту.

    6. Помилка відкриття файлу у режимі запису: якщо файл уже відкритий у режимі запису, то виникає помилка, якщо спробувати відкрити його в режимі запису знову.

Але якщо під час запису у файл програма впіймає виключення (внаслідок одної з перелічених вище помилок), файл ніколи не буде закритий. Тому варто використовувати контекстний менеджер with: 

```python
with open('file.txt','w') as f:
    f.write('hello') 
```

Оператор контекстного менеджера автоматично закриває файл, коли виконання блоку with закінчується. Це означає, що ви більше не маєте проблеми з закриттям файлу вручну, що допомагає уникнути помилок, пов'язаних з відкриттям та закриттям файлів, які можуть виникнути, якщо ви відкриєте файл вручну, і забудете закрити його пізніше. Також його використання робить код більш читабельним.

## Практика

- Кожен пише суму списку за допомогою for та while
- Написати програму, яка виводить сама себе
- Написати програму, яка виводить саму себе задом наперед
- Банкомат видає суму максимально можливими купюрами
- Банкомат видає суму дрібними, але не більше 10 штук кожної дрібної купюри

## Корисні посилання


[Робота з файлами](https://pythonworld.ru/tipy-dannyx-v-python/fajly-rabota-s-fajlami.html)

[Домашка](hw03.md)
