# Урок 3. Цикли For та While, робота з файлами

## Оператори циклу

Коли в програміста виникає необхідність повторити якусь дію кілька разів, він пише цикл.
У python є оператори циклу 'while' та 'for'.
У більшості випадків оператори циклу взаємозамінні, але кожен з них має деякі нюанси.

## Цикл while

Найпростіший оператор циклу while виглядає так:

**`while умова: дія`**

або

**`while умова: блок дій в декілька рядків`**

Логічно і синтаксично оператор циклу `while` дуже схожий з оператором розгалуження `if`. У обох випадках відбувається перевірка умови, і у разі її істинності (тобто умова=`True`) виконуються команди, які у такому випадку називаються "тілом циклу". І, так само як і у випадку з `if`, у циклів у Пайтоні може бути повне розгалуження із застосуванням гілки 'else', яке буде виконуватись у разі хибності умови (тобто умова=`False`). Головна відмінність між `if` та `while` полягає у тому, що при розгалуженні команди виконуються одноразово, а у циклі інтерпретатор повертається до початкової перевірки умови після кожного повтору циклу.

```python
i = res = 0

while i < 11:
    res += i
    i += 1

print(res)
```

## Вічний (нескінченний) цикл

![](http://risovach.ru/upload/2015/02/mem/fon_73228276_orig_.jpg)

У програмуванні часто використовуються вічні цикли. Просто є ситуації, коли немає явного обмеження і умову важко перевірити заздалегідь. Для того, щоб вийти з вічного циклу і взагалі з циклу, використовується оператор `break`. Він працює всередині циклу та припиняє його виконання. Далі проілюстровано роботу оператора `break` та оператора `continue`, який припиняє поточну ітерацію та починає наступну:

```python
i = 10
while True:
    i -= 1
    if not i: continue
    if i%2:
        print(i)
    if i < -10: break
```

У цій можливості оператору `while` криється його небезпека: якщо неграмотно скласти обробку умови та її зміну всередині тіла циклу, то він легко увійде у режим вічного повтору і програма може просто підвиснути. Також у циклу `while`, завдяки факту перевірки умови ПЕРЕД здійсненням дій з інформацією є можливість, при неграмотному складанні алгоритму вчинити одну лишню ітерацію (повтор тіла циклу) і видати результат відмінний від очікуваного. Цих недоліків позбавлений наступний оператор циклу, який деякі ортодоксальні програмісти також прирівнюють до "синтаксичного цукру".

## Оператор циклу for

На відміну від `while` оператор циклу `for` має явно вказану кінцевість, оскільки здійснює повтори виключно згідно з кількістю елементів ітерованого об'єкта, який йому передається.
Те саме підсумовування перших 10 елементів, що й за допомогою циклу `while`, але за допомогою `for`:

```python
sum = 0

for i in range(1, 11):
    sum += i

print(sum)
```

У цьому випадку використано генераторний вираз range(a,b,c), який створює послідовність цілих чисел починаючи з `a` до, але не включаючи `b`, з кроком `c`. Слід зазначити, що для даного генератора параметри `a` та `c` не є обов'язковими.

Оскільки цикл `for` виконується в рамках ітерованого об'єкта, то він чуже часто використовується для перебору значень цього самого ітерованого об'єкта (рядка, генератора, списку, кортежу тощо):

```python
sum = []

for i in 'word':
    sum += i

print(sum)
```

Бувають ситуації, коли виникає необхідність не просто поелементного перебору ітерованого об'єкта, але й встановлення індексу кожного його елемента. У цьому випадку використовується метод `enumerate()`, котрий додає до ітерованого об'єкта лічильник і повертає його у вигляді нумерованого об'єкта. Цей нумерований об'єкт надалі може бути використаний напряму у циклах `for` або конвертований у список, кожен елемент якого є кортежем, за допомогою функції `list()`.

Синтаксис функції:

`enumerate(iterable, start=0)`

де: iterable - ітерований об'єкт; start - початкове значення індексу (0 за замовчуванням)

```python
a = [10, 20, 30, 40]

for id, item in enumerate(a):
    a[id] = item + 5

print(a)

[15, 25, 35, 45]
```

Слід зазначити, що внутрішня реалізація у Пайтоні циклу `for` є швидшою за код циклу `while`. І при одних і тих самих умовах цикл `for` виконається приблизно на 20-50% швидше.

## Базова робота з файлами

Для роботи з файлами вам потрібні такі функції:

* open
* write
* read
* close

Приклади:

```python
import sys
filename = sys.argv[1]
# далі відкриваємо файл для читання (опція 'r')
f = open(filename, 'r') # в файлі тепер file descriptor

for line in f: # для кожного рядка у файлі
    print(line)

f.close() # закриття файлу

```

Тут треба звернути увагу на такі рядки:

**`import sys`** - включення до нашої програми бібліотеки системних функцій, з допомогою якої ми можемо працювати з параметрами командного рядка, наприклад.

**`filename = sys.argv[1]`**, де **`sys.argv`** - функція системної бібліотеки `sys`. Вона зчитує перший параметр зі списку параметрів командного рядка.

Якщо здійснимо виклик файлу нашої програми prog.py в консолі, і передамо їй файл ось так:

```bash
C:\python3\python.exe prog.py testfile.txt
```

...то python вважає за нульовий параметр ім'я нашої програми (prog.py), першим = ім'я переданого файлу (testfile.txt), другим - наступний параметр, якщо він є, і так далі.

Таким чином ми передали програмі файл, прочитали його по рядках та вивели. На цей час поки що по роботі з файлами цього достатньо.

Для відкриття файлу у режимі запису до нього використовується та ж функція open(), але вже з ключем `w`. А безпосередньо для запису у нього використовується метод .write(). Однак запис у файл має декілька підводних каменів. Зокрема, у багатьох підручниках записано такий приклад для запису і закриття файлу:

```python
f=open('file.txt','w')
f.write('hello')
f.close()
```
Але при використанні даного алгоритму можуть виникати наступні помилки:

1. Помилка доступу: може виникнути помилка, якщо користувач не має дозволу на запис до файлу. Наприклад, якщо файл вже відкритий у іншому додатку або якщо користувач не має достатніх дозволів на запис до файлу.

2. Помилка шляху до файлу: може виникнути помилка, якщо файл не знайдено в заданому шляху. Перевірте, чи існує файл в заданому шляху, а також чи вірно вказаний шлях до файлу.

3. Помилка запису: може виникнути помилка, якщо не вдалося записати дані до файлу. Наприклад, якщо недостатньо пам'яті на диску або якщо диск заблокований.

4. Помилка відкриття файлу: може виникнути помилка, якщо файл не відкривається. Наприклад, якщо файл уже відкритий в іншому процесі або якщо він був переміщений або видалений.

5. Помилка кодування: може виникнути помилка, якщо використовується неправильне кодування файлу. Наприклад, якщо використовується кодування, відмінне від кодування файлу, то можуть виникнути проблеми з відображенням тексту.

6. Помилка відкриття файлу у режимі запису: якщо файл уже відкритий у режимі запису, то виникає помилка, якщо спробувати відкрити його в режимі запису знову.

Якщо під час запису у файл програма впіймає виключення (внаслідок одної з перелічених вище помилок), файл ніколи не буде закритий. Тому варто використовувати контекстний менеджер `with`:

```python
with open('file.txt','w') as f:
    f.write('hello')
```

Оператор контекстного менеджера автоматично закриває файл, коли виконання блоку `with` закінчується. Це означає, що ви більше не маєте проблеми з закриттям файлу вручну, що допомагає уникнути помилок, пов'язаних з відкриттям та закриттям файлів, які можуть виникнути, якщо ви відкриєте файл вручну, і забудете закрити його пізніше. Також його використання робить код більш читабельним.

## Практика

- Кожен пише суму списку за допомогою `for` та `while`
- Написати програму, яка виводить сама себе
- Написати програму, яка виводить саму себе задом наперед
- Банкомат видає суму максимально можливими купюрами
- Банкомат видає суму дрібними, але не більше 10 штук кожної дрібної купюри

## Корисні посилання

[Робота з файлами](https://tproger.ru/articles/files-in-python/)


## Домашнее задание №3

1. Завершити практичні завдання з заняття.
2. Написати fizzbuzz для 20 комплектів по три числа, які записані в файл. Читайте із файлу перший рядок з трьома числами, беріть із нього числа, рахуйте для них fizzbuzz, виводите, продовжуйте з наступним рядком і так до кінця файла. 
3. Переробити другу задачу так, щоб результат писався в інший файл.

