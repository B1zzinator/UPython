## Виведення даних

Для виведення даних використовується функція `print`:

```python
int1 = 4
str1 = "8"
print(int1)   #виводить 4
print('text') #виводить text
print("text") #виводить text
print(str1)   #виводить 8
```
Однак, print має більше можливостей, ніж звичайне виведення об'єкта.

Синтаксис:
print( *objects , sep='' , end='\n' , file=sys.stdout , flush=False )

Іменовані параметри управляють поведінкою функції.

Параметр sep=' ' – рядок-розділювач, він буде вставлений між кожним з неіменованих параметрів переданих у print(). За замовчуванням - ' '.

>>> print('The', 'Py', 'U', sep='/')
The/Py/U

>>> lst = ['p', 'y', 't', 'h', 'o', 'n']
>>> print(*lst, sep=', ')
p, y, t, h, o, n

Якщо передати sep='\n', кожен параметр буде виведено з нового рядка.

Параметр end='\n' – буде виведено після друку останнього аргументу. За умовчанням переклад рядка (друкувати в один рядок - end='')

>>> print('The', end='')
... print('PyU')
ThePyU

Параметр file=sys.stdout вказує файл або потік, в який буде виводитись інформація, за замовчуванням, це стандартний вивід sys.stdout.

Друк у файл:

>>> f = open('test.txt', 'w')
>>> print("hello", file=f)
>>> f.close()

Параметр flush=False використовується разом із file, який дозволяє вказувати об'єкт файлу, куди потрібно записати виведені дані. False - запис у файл відбудеться після виходу з циклу, True - запис у файл буде зроблено відразу.

Слід враховувати, що сама функція print() відноситься до таких, що нічого не повертають. Тому, якщо ви надрукутєте щось на зразок print(print('0')), то у вас спочатку спрацює огорнута функція і виведе '0', а потім функція, що її огортає, для якої вхідним параметром буде None (адже огорнута функція нічого не повертає), що і буде далі виведено.

Особливістю функції print() є те, що у якості аргументу до неї можна передавати не лише текст, значення змінних, але й обчислення, чи іншу функцію. Правда лише у випадку, якщо результат такого обчислення більше ніде не буде використовуватись:

```python
print(round((220/4)**0.5, 2))   #виводить 7.42
```

Також Пайтон підтримує чотири способи форматування даних при їх вивденні через функцію print():
1. Шляхом простого перерахування чи конкатенації тексту та значень:
name='Alex'
age=12
print('Hello! My name is ', name, 'and i\'m ', age, 'years old')

2. Трошки застарілий С-подібний спосіб форматування тексту через оператор %:
name='Alex'
age=12
print('Hello! My name is %s and i\'m %d years old' %(name,age))

3. F-строчки, або інтерполяція рядків. Починаючи з версії Пайтона 3.6 з'явилась можливість використовувати так-звані ф-строчки. Цей новий спосіб форматування рядків дозволяє використовувати вбудовані вирази Python всередині рядкових констант.

name='Alex'
age=12
print(f'Hello! My name is {name} and i\'m {age} years old')

Оскільки у пайтоні будь-що є об'єктом, то всередину фігурних скобок ви можете вкласти посилання на будь-які дані, чи функції, результат роботи яких і буде передано у якості даних для виведення. Слід також враховувати, що f-строчки опрацьовуються Пайтоном саме як даны типу string, що дозволяє, наприклад задавати геометрію вікна при створенні графічного інтерфейсу програми з використанням модулю tkinter через значення окремих змінних.
Також всередині фігурних дужок ви можете форматувати результати обчислень у широкому діапазоні:
а) змінити систему счислення при виведенні даних - 
print(f'hex: {42:X}, bin: {12:b}') #hex: 2A, bin: 1100
б) визначити кількість відображуваних знаків після коми - 
from math import pi
print(f'{pi:.3f}') #3.142
в) заповнити місце перед значенням будь-якими символами за вибором -
print(f' hex: {12:0>3X}') # hex: 00C
print(f' hex: {12: >3X}') # hex:   C

4. Метод .format(). Починаючи з версії пайтона 3, з'явилась можливість використовувати метод .format() для створення шаблонів строчок, у які в подальшому можна вносити значення зі змінних. Хоча, з появою ф-строчок деякі програмісти стали вважати цей метод застарілим, але існують ситуації, коли використання форматованої строчки є зручнішим за створення декількох ф-строчок. Наприклад ситуація, коли один і той же формат виводу використовується у різних місцях коду:

congrats='Congratulation, {}! Your score is {}'
"Тут багато строчок коду"
congrats.format(player1.name, player1.score)
"Ще куча строчок коду"
congrats.format(player2.name, player2.score)

Чи, наприклад, зробити такий трюк зі словником:
user_data='{first_name} {last_name} is {age} years old'
user1={'first_name':'Alex', 'last_name': 'Boldwin', 'age': 52}
print(user_data.format(**user1)) #Alex, Boldwin is 52 years old 

І таких словників може бути декілька

## Введення даних
Для введення даних з консолі у мові пайтон використовується функція input(). Функція input() відноситься до таких, що передають назовні дані, отримані нею у якості аргумента. у якості аргумента дана функція отримує дані введені у консоль, а результатом її роботи є дані типу String (рядок), які вона передає назовні.
a=input() #<- сюди щось вводимо
print(a, type(a)) #-> тут отримуємо назад введені дані та їх тип - String

Дана функція також може містити текстрову строчку запиту, яка буде виводитись у консоль перед курсором, що очікує введення даних. Використання подібних строчок дає змогу користувачу розуміти що саме від нього вимагається ввести.

a=input('Введіть ціле число від 1 до 100: ')

Оскільки функція input() передає назовні дані типу "рядок", якщо нам потрiбно перетворити їх у інший тип даних, її варто огортати відповідною функцією перетворення даних. наприклад:
a=int(input())
b=float(input())
c=bool(input())
і так далі. У випaдку, якщо ви будете використовувати функції перетворення даних у дані контейнерного типу (list, tuple, set), то елементами даних контейнерів буде кожний окремий символ введеної послідовності.

b=set(input()) #<- ввели 3498432
print(b, type(b)) #-> отримали {'4', '3', '9', '2', '8'} <class 'set'>

Якщо вам потрібно сторити контейнер відомої довжини, варто використовувати List comprehension (абстракцію або генератор списку):
a=[input() for _ in range(3)]

У даному прикладі створюється список з трьох елементів типу "строчка", які при введенні розділяються Enter-ом. Зверніть увагу на використання службової змінної _ яка після викоританя не зберігає своє значення далі у пам'яті, на відміну від поіменованих змінних.

У випадку, якщо вам необхідно вводити дані через пробіл, чи інший символ, варто використоувати метод .split(), якому у якості аргумента передається символ розділення (за замовчуванням - пробіл)
Приклад: 
a=list(input().split())

Але у даному випадку кожний елемент списку буде мати тип даних String. Якщо вам потрібно перетворити введені дані у інший тип, наприклад int, то варто викристовувати функцію map(), яка у якості першого аргументу примає необхідну функцію чи дію, яку необхідно застосувати до кожного елемента контейнера, а у якості другого аргумента - ім'я контейнера, чи писок його елементів.
Приклад:

a=list(map(int, input().split()))

У даному приклад буде створено список довільної довжини, який буде складатись з елементів типу Integer, введених через пробіл. Також ви можете не створювати список. а одразу розпакувати кожен його елемент до відповідних змінних

a,b,c,d=map(int, input().split())

у обидвох прикладах вище натиснення клавіші Enter припинить введення даних. Але у випадку розпакоки слід пам'ятати про необхідність точного співпадіння кількості введених значень справа від знаку "=" та імен змінних зліва від нього.

Щоб запобігти виникненню помилки ValueError: too many values to unpack, варто спочатку змінні ввести в список, а потім його розпакувати:

a=list(map(int, input().split()))
b,c,d=a[:3]

У цьому випадку до змінних b, c, d будуть розпаковані значення перших трьох елементів списку А.